
1. Set及其實現類別特點
java.util.Collection 儲存單一數據
    |----子介面: Set: 儲存無序的、不可重複的數據
            |---HashSet: 主實現類別，底層使用HashMap(陣列+單向鏈表+紅黑樹結構)
                |---LinkedHashSet: HashSet的子類:在HashSet的基礎結構上，增加一組雙向鏈表
                                   用於記錄元素的增加順序,可以按照元素新增順序進行遍歷，便於
                                   頻繁的查詢操作。
            |---TreeSet:底層使用紅黑樹儲存。可以按照添加的元素的指定的屬性的大小順序進行遍歷

2. 開發中的使用頻率及場景:
> 相較於List與Map, Set使用頻率較低
> 用於過濾重複數據

3. Set中的常用方法:即為Collection中宣告的15個抽象方法，無新增其他方法

4. Set中無序性、不可重複性的理解

>無序性:不等於隨機性
       添加元素的順序和遍歷元素的順序不一致，是否就是無序性？ No!
       何為無序性？與添加元素的位置有關、不像ArrayList一樣是依次緊密排列的。
       是根據添加的元素的hash值，計算其在陣列中的位置，此位置不是依次緊密排序的
       表現為無序性

>不可重複性:添加到Set中的元素是不能相同的。
          比較的標準需要判斷hashcode()得到的hash值與equals()得到boolean的結果。
          兩者皆相同，則認為元素是相同的

5. 添加到HashSet/LinkedHashSet中元素的要求
   要求元素所在的類別需要重寫 equals() 和 hashCode() 兩個方法
   同時, 要求equals() 和 hashCode() 要保持一致性!只需要在IDEA自動產生兩個方法的重寫即可保證一致性

6. TreeSet的使用
6.1 底層的資料結構: 紅黑樹

6.2 新增資料後的特點:可以按照新增的元素指定的屬性大小順序進行遍歷

6.3 向TreeSet添加的元素的要求
>要求添加到TreeSet中的元素必須是同一類型的物件，否則會產生例外ClassCastException
>添加的元素需要考慮排序 ①自然排序 ②定制排序

6.4 判斷資料是否相同的標準
> 不再是考慮hashCode()和equals()方法了,因此增加到TreeSet中元素的類別無須重寫hashCode()與equals()
> 比較元素的標準為 自然排序中的 compareTo()或 定制排序中 compare() 的返回值是否為0，則表示兩者相等
  由於TreeSet中無法儲存相同的元素，所以後一個相同的元素就不能被新增到TreeSet中


