
1. 執行緒之間溝通的理解
需要多個執行緒間共同完成一件任務,並且希望它們有規律的執行,因此多執行緒之間需要一些溝通機制協調工作，實現共同操作同一份資料

2.涉及到三個方法的使用
wait():執行緒一旦執行此方法，就進入等待狀態。同時會釋放鎖定的物件
notify():一旦執行此方法，就會喚醒被wait()的執行緒優先順序最高的那一個(如果被wait()的多個執行緒優先順序相同
         會隨機喚醒一個). 被喚醒的執行緒將從被wait()的位置繼續向後執行
notifyAll():一旦執行此方法，就會喚醒所有被wait()的執行緒

3.注意點
>此三個方法的使用，必需是在synchronized{} 與synchronized method中
 (Lock需要配合Condition實現執行緒間的溝通)
>需透過鎖定的物件調用此三個方法，否則會出現IllegalMonitorStateException例外
>此三個方法定義在Object類中

4.案例
案例1: 使用2個執行緒交替列印1~100

案例2: 生產者和消費者 (Producer-consumer problem)
生產者(Productor)將產品交給店員(Clerk)，而消費者(Customer)從店員處取走產品，店員一次只能持有固定數量的產品(比如:20）
，如果生產者試圖生產更多的產品，店員會叫生產者停一下，如果店中有空位放產品了再通知生產者繼續生產；如果店中沒有產品了，店員
會告訴消費者等一下，如果店中有產品了再通知消費者來取走產品。

5.wait()和sleep()區別?
共同點,執行後，執行緒都會進入阻塞狀態

差異點
>宣告的位置:wait()在Object類別中
          sleep()在Thread類別中,為靜態方法

>使用場景：wait()只能使用在synchronized區塊或 只能使用在synchronized method中
         sleep() 可以在任何需要使用的場景

>使用在synchronized中:wait() 會釋放鎖定的物件
                    sleep() 不會釋放鎖定的物件

>結束阻塞狀態的方式:wait() 到達指定時間自動結束阻塞 或 通過notify方法喚醒
                sleep() 到達指定時間自動結束阻塞

