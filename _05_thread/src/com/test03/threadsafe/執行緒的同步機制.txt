
執行緒的安全問題與執行緒的同步機制

1.多執行緒賣票, 出現的問題:
>出現了重票和錯票

2.發生的原因為何?
>執行緒1在操作ticket過程尚未結束的情況下，其他執行緒參與進來對ticket操作

3.如何解決？
>必需保證同時只能有一個執行緒在操作ticket

4.Java是如何解決執行緒的安全問題的？
>使用執行緒的同步機制

方式一 Synchronized 程式碼

synchronized(鎖定的物件){
    //需要被同步的程式碼
}

說明
>需要被同步的程式碼:當程式中會取出某一個共用的物件且會判斷物件內容值，再更新物件內容時
>共用的物件:多個執行緒都會操作的物件
>需要被同步的程式碼被synchronized包裹後，就使得一個執行緒在執行此動作時，其他執行緒需等待
>哪個執行緒獲得 SomeObject ，就能執行需要被同步的程式碼
>鎖定的物件可以使用任何一個Class, 但多個執行緒必須共用同一個Instance

注意，在 implements Runnable 方式中 SomeObject 可以考慮使用this
     在 extends Thread 方式中, 要慎用this, 可以考慮使用當前類.class

方式二 Synchronized method

說明
>如果操作共用數據的程式碼完整寫在一個方法中，就可以將此方法宣告為Synchronized method即可
>非靜態的鎖定的物件預設為 this
   靜態的的鎖定的物件預設為當前類本身(Windows.class)

5. synchronized優點: 解決了執行緒安全問題

   弊端: 在操作共同物件時, 多執行緒其實是串列執行的, 效能低落。